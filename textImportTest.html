<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<script src="zepto.js"></script>
<script src="tween.min.js"></script>
<!--three.js库文件-->
<script src="three.min.js"></script>
<!--用于加载mtl格式的材质库文件-->
<script src="loaders/MTLLoader.js"></script>
<!--用于加载obj格式的模型网格文件-->
<script src="loaders/OBJLoader.js"></script>
<body>
	
</body>
<script>
	var container;

	var camera, scene, raycaster, renderer;
	var mouse = new THREE.Vector2(), INTERSECTED;
	mouse.x = -9999;
	mouse.y = -9999;
	var Objs = [];
	var layer = document.getElementById('layer');
	var content =  document.getElementById('content');
	var close =  document.getElementById('close');
	var St = +(new Date());

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var textMaterial = new THREE.MeshBasicMaterial( {
        color: 0x26dffd
    } );
	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
		camera.position.z = 0;

		// scene

		scene = new THREE.Scene();
		raycaster = new THREE.Raycaster();

		// var ambient = new THREE.AmbientLight( 0x000000 );
		// scene.add( ambient );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 0, 0, 1 ).normalize();
		scene.add( directionalLight );

		// model

		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) { 
			alert('模型加载失败，请刷新页面重新加载');
		};
		function setObjPositions(){	
			Objs.forEach(function(o,i){
				if(i === 0){
					o.position.z = -700;
				} else {
					o.position.z = -2000;
					o.visible = false;
				}
			});
		}
		var mtlLoader = new THREE.MTLLoader();
		mtlLoader.setPath( 'obj/' );
		mtlLoader.load( 'ball.mtl', function( materials ) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			//objLoader.setMaterials( materials );
			objLoader.setPath( 'obj/' );
			objLoader.load( 'pm.obj', function ( object ) {
				console.log(object);
				object.scale.x = .5;
				object.scale.y = .5;
				object.scale.z = .5;
				object.children.forEach(function(textchild){
					textchild.material = textMaterial;
				}) 
				Objs.push(object);
				scene.add( object );
				if(Objs.length === 4){
					setObjPositions();
				}
			}, onProgress, onError );
		});
		mtlLoader.load( '裂缝星球.mtl', function( materials ) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials( materials );
			objLoader.setPath( 'obj/' );
			objLoader.load( '裂缝星球.obj', function ( object ) {
				Objs.push(object);
				scene.add( object );
				if(Objs.length === 4){
					setObjPositions();
				}
			}, onProgress, onError );
		});
		mtlLoader.load( '小转星球.mtl', function( materials ) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials( materials );
			objLoader.setPath( 'obj/' );
			objLoader.load( '小转星球.obj', function ( object ) {
				Objs.push(object);
				scene.add( object );
				if(Objs.length === 4){
					setObjPositions();
				}
			}, onProgress, onError );
		});
		mtlLoader.load( '小刺.mtl', function( materials ) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials( materials );
			objLoader.setPath( 'obj/' );
			objLoader.load( '小刺.obj', function ( object ) {
				Objs.push(object);
				scene.add( object );
				if(Objs.length === 4){
					setObjPositions();
				}
			}, onProgress, onError );
		});

		document.ontouchmove = function(ev){ev.preventDefault()}
		$('body').on('swipeDown', function(){
			if(Objs.length === 4){
				Objs.push(Objs.shift());
				Objs[3].visible = false;
				Objs[3].position.z = -2000;
				Objs[3].rotation.y = 0;
				Objs[0].visible = true;
				new TWEEN.Tween(Objs[0].position).to({
					z: -700
				},2000).start();
				new TWEEN.Tween(Objs[0].rotation).to({
					y: Math.PI
				},2000).start();
			}
		});
		renderer = new THREE.WebGLRenderer({antialias:true});
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener('touchstart',onDocumentTouchDown, false);

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	}

	function onDocumentTouchDown(event){
		mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
	}
	function animate(time) {
		requestAnimationFrame( animate );
		TWEEN.update(time);
		render();
	}

	function render() {
		renderer.render( scene, camera );

	}
</script>
</html>